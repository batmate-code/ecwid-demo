import { ReactNode } from 'react';
import { renderHook } from '@testing-library/react';
import { MemoryRouter } from 'react-router-dom';
import { useCategoriesNavigation } from '@/pages/ProductsCatalog/hooks//useCategoriesNavigation';
import type { Category } from '@/api/apiTypes/shopApiTypes';

const navigateMock = vi.fn();
vi.mock('react-router-dom', async () => {
  const actual = await vi.importActual('react-router-dom');
  return {
    ...actual,
    useNavigate: () => navigateMock,
  };
});

const withRouter =
  (initialUrl: string) =>
  ({ children }: { children: ReactNode }) => (
    <MemoryRouter initialEntries={[initialUrl]}>{children}</MemoryRouter>
  );

const categories: Category[] = [
  { id: 1, name: 'Category-1', autogeneratedSlug: 'category-1' },
  { id: 2, name: 'Subcategory-1', autogeneratedSlug: 'subcategory-1', parentId: 1 },
  { id: 3, name: 'Subcategory-2', autogeneratedSlug: 'subcategory-2', parentId: 1 },
  { id: 4, name: 'Category-2', autogeneratedSlug: 'category-2' },
];

beforeEach(() => {
  navigateMock.mockReset();
});

describe('useCategoriesNavigation', () => {
  it('returns roots as visible categories and no backHref/breadcrumbs', () => {
    const { result } = renderHook(() => useCategoriesNavigation(categories), {
      wrapper: withRouter('/'),
    });

    expect(result.current.currentCategoryId).toBeUndefined();
    expect(result.current.backHref).toBeUndefined();
    expect(result.current.breadcrumbItems).toEqual([]);

    const labels = result.current.visibleCategories.map((category) => category.label);
    expect(labels).toEqual(['Category-1', 'Category-2']);

    const hrefs = result.current.visibleCategories.map((category) => category.href);
    expect(hrefs[0].startsWith('/category-1')).toBe(true);
    expect(hrefs[1].startsWith('/category-2')).toBe(true);
  });

  it('at /category-1, breadcrumb is one item and children are visible', () => {
    const { result } = renderHook(() => useCategoriesNavigation(categories), {
      wrapper: withRouter('/category-1'),
    });

    expect(result.current.breadcrumbItems).toHaveLength(1);
    expect(result.current.breadcrumbItems[0]).toMatchObject({
      name: 'Category-1',
    });
    expect(result.current.breadcrumbItems[0].path.startsWith('/category')).toBe(true);

    const labels = result.current.visibleCategories.map((c) => c.label);
    expect(labels).toEqual(['Subcategory-1', 'Subcategory-2']);
    expect(result.current.currentCategoryId).toBe(1);
    expect(result.current.backHref).toBeDefined();
  });

  it('at /category-1/subcategory-1, breadcrumbs are two items and no children are visible', () => {
    const { result } = renderHook(() => useCategoriesNavigation(categories), {
      wrapper: withRouter('/category-1/subcategory-1'),
    });

    expect(result.current.currentCategoryId).toBe(2);
    expect(result.current.visibleCategories).toEqual([]);
    expect(result.current.backHref).toBeDefined();
    expect(result.current.backHref!.startsWith('/category-1')).toBe(true);
  });

  it('redirects to "/" when a slug is invalid (after categories are known)', async () => {
    renderHook(() => useCategoriesNavigation(categories), {
      wrapper: withRouter('/category/unknown?query=x&page=3'),
    });

    const [to, opts] = navigateMock.mock.calls[0];
    expect(typeof to).toBe('string');
    expect(opts.replace).toBe(true);
    expect(to.startsWith('/')).toBe(true);
  });

  it('does not redirect if categories are not loaded yet (empty list)', () => {
    renderHook(() => useCategoriesNavigation([]), {
      wrapper: withRouter('/category/unknown'),
    });

    expect(navigateMock).not.toHaveBeenCalled();
  });
});
