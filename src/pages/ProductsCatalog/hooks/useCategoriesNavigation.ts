import { useLocation, useNavigate } from 'react-router-dom';
import { useEffect, useMemo } from 'react';
import { useBuildUrl } from './useBuildUrl';
import type { Category } from '@/api/apiTypes/shopApiTypes';

export interface CategoryNode extends Category {
  children: CategoryNode[];
}
export type CategoryItem = { id: number; label: string; href: string };

type BreadcrumbItem = { name: string; path: string };

interface useCategoriesNavigationData {
  breadcrumbItems: BreadcrumbItem[];
  visibleCategories: CategoryItem[];
  currentCategoryId?: number;
  backHref?: string;
}

/**
 * Builds the category tree (roots + children) in a single pass.
 * Nodes with missing parent are treated as roots.
 */
const buildTreeAndIndex = (categories: Category[]) => {
  const byId = new Map<number, CategoryNode>();
  for (const c of categories) byId.set(c.id, { ...c, children: [] });

  const roots: CategoryNode[] = [];
  for (const node of byId.values()) {
    if (node.parentId == null) {
      roots.push(node);
    } else {
      const parent = byId.get(node.parentId);
      if (parent) parent.children.push(node);
      else roots.push(node);
    }
  }
  return { roots };
};

/**
 * Resolves a breadcrumb-like trail from slugs by walking level-by-level through children
 * Starts at roots, then goes into .children on each match.
 * Stops at the first missing slug and returns the resolved part.
 */
const resolveTrailBySlugs = (slugs: string[], roots: CategoryNode[]) => {
  const trail: CategoryNode[] = [];
  let currentLevel = roots;

  for (const slug of slugs) {
    const next = currentLevel.find((n) => n.autogeneratedSlug === slug);
    if (!next) break;
    trail.push(next);
    currentLevel = next.children;
  }
  return trail;
};

/**
 * Hook that:
 * - builds the tree from categories,
 * - resolves the current trail from URL (by slugs),
 * - returns breadcrumbs, visible categories, current category id, and a back link,
 * - preserves current query params on all links and resets page to 1 on category change,
 * - redirects to "/" if URL contains an invalid slug.
 */
export const useCategoriesNavigation = (categories: Category[]): useCategoriesNavigationData => {
  const { buildUrl } = useBuildUrl();
  const navigate = useNavigate();
  const location = useLocation();

  const { roots } = useMemo(() => buildTreeAndIndex(categories), [categories]);

  const slugs = useMemo(
    () => location.pathname.replace(/^\//, '').split('/').filter(Boolean),
    [location.pathname],
  );
  const trail = useMemo(() => resolveTrailBySlugs(slugs, roots), [slugs, roots]);
  const current = trail.at(-1);

  /**
   * Breadcrumb items for UI. Paths are built with join (no "//"),
   * wrapped with buildUrl to preserve current query and reset page.
   */
  const breadcrumbItems: BreadcrumbItem[] = useMemo(
    () =>
      trail.map((node, i) => {
        const rawPath = '/' + slugs.slice(0, i + 1).join('/');
        return {
          name: node.name,
          path: buildUrl(rawPath, { resetPage: true }),
        };
      }),
    [trail, slugs, buildUrl],
  );

  /**
   * Visible categories at the current level: mapped to {id,label,href}.
   * Hrefs preserve query and reset page. Path built safely with segment join.
   */
  const visibleCategories = useMemo(() => {
    const items = current ? current.children : roots;

    return items.map((item) => {
      const rawPath = '/' + [...slugs, item.autogeneratedSlug].filter(Boolean).join('/');
      return {
        id: item.id,
        label: item.name,
        href: buildUrl(rawPath, { resetPage: true }),
      };
    });
  }, [current, roots, slugs, buildUrl]);

  /**
   * Link to the parent level (or undefined on root). Preserves query and resets page.
   */
  const backHref = useMemo(() => {
    if (slugs.length === 0) return undefined;
    const parentPath = '/' + slugs.slice(0, -1).join('/');
    return buildUrl(parentPath || '/', { resetPage: true });
  }, [slugs, buildUrl, location.search]);

  /**
   * Redirect to "/" when URL contains an invalid slug,
   * but only after categories were loaded.
   */
  useEffect(() => {
    if (categories.length === 0) return;
    const pathIsBroken = slugs.length > 0 && trail.length < slugs.length;
    if (pathIsBroken) {
      navigate(buildUrl('/', { resetPage: true }), { replace: true });
    }
  }, [categories.length, slugs, trail, navigate, buildUrl]);

  return {
    breadcrumbItems,
    visibleCategories,
    currentCategoryId: current?.id,
    backHref,
  };
};
